## Due.js 是什么

Due (读音 /djuː/)，是一套高度模仿 Vue.js 的 MVVM 小框架，Due 实现了 Vue.js 的基本功能，持续更新中...

目录结构

```plain
frontend-mvvm
├─ .git
│    ├─ HEAD
│    ├─ config
│    ├─ description
│    ├─ hooks
│    │    ├─ applypatch-msg.sample
│    │    ├─ commit-msg.sample
│    │    ├─ fsmonitor-watchman.sample
│    │    ├─ post-update.sample
│    │    ├─ pre-applypatch.sample
│    │    ├─ pre-commit.sample
│    │    ├─ pre-merge-commit.sample
│    │    ├─ pre-push.sample
│    │    ├─ pre-rebase.sample
│    │    ├─ pre-receive.sample
│    │    ├─ prepare-commit-msg.sample
│    │    ├─ push-to-checkout.sample
│    │    └─ update.sample
│    ├─ index
│    ├─ info
│    │    └─ exclude
│    ├─ logs
│    │    ├─ HEAD
│    │    └─ refs
│    ├─ objects
│    │    ├─ info
│    │    └─ pack
│    ├─ packed-refs
│    └─ refs
│           ├─ heads
│           ├─ remotes
│           └─ tags
├─ TestChatGroup.html
├─ TestVue.html
├─ a.png
├─ axios.js
├─ core
│    ├─ index.js
│    ├─ instance
│    │    ├─ grammer
│    │    ├─ index.js
│    │    ├─ init.js
│    │    ├─ mount.js
│    │    ├─ proxy.js
│    │    └─ render.js
│    ├─ util
│    │    ├─ Code.js
│    │    ├─ KeyWordsUtil.js
│    │    └─ ObjectUtil.js
│    └─ vdom
│           └─ vnode.js
└─ test
       └─ Due.js

```

## 起步：

> Due.js 假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。

> Due 框架追求轻量，简洁的风格，这里的挂载 el 只支持 id 挂载。

下载：

引入：

## 声明式渲染

```js
let app = new Due({
  el: "app",
  data: {
    message: "Hello Due!",
  },
});
```

我们已经成功创建了第一个 Due 应用！看起来这跟渲染一个字符串模板非常类似，但是 Due 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是**响应式的**。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 `app.message` 的值，你将看到上例相应地更新。

注意我们不再和 HTML 直接交互了。一个 Due 应用会将其挂载到一个 DOM 元素上 (对于这个例子是 `#app`) 然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Due 实例内部。

# 功能实现

## Data 代理

> 代理对象

> 代理嵌套的对象

- namespace 命名空间，主要解决对象嵌套，表示当前修改的东西是什么。比如，test.content，test.obj.a，后者就具有 obj 的命名空间。对象往下传递的时候就有了自己的命名空间：上一级传过来的命名空间+当前属性名。

> 代理数组

- 主要实现是对数组原型上的方法进行代理

## 虚拟 DOM 树

### vnode

> 结构

```js
export default class VNode {
  /**
   *
   * @param {*} tag //标签类型DIV，SPAN, INPUT, 文本节点:#TEXT
   * @param {*} elm // 对应的真实节点
   * @param {*} children //当前节点下的子节点
   * @param {*} text // 当前虚拟节点中的文本
   * @param {*} data // VNodeData,暂时保留，暂无 保留字段
   * @param {*} parent // 父级节点
   * @param {*} nodeType // 节点类型
   */
  constructor(tag, elm, children, text, data, parent, nodeType) {
    this.tag = tag;
    this.elm = elm;
    this.children = children;
    this.text = text;
    this.data = data;
    this.parent = parent;
    this.nodeType = nodeType;
    this.env = {
      // 当前节点的环境变量，用于存在自己声明的变量，让子节点继承
    };
    this.instructions = null; //存放指令
    this.template = []; // 当前节点涉及到的模板
  }
}
```

### 建立虚拟 DOM 树

允许先不传递 el，把 due 对象创建完了后再用 mount 方法挂载。

建立虚拟 dom 树，深度优先搜索

## 内容渲染

### 构建模板节点索引

> 模板和节点的映射

- 通过模板找到那些节点用到了这个模板：to->2 for->4

- 进行预备渲染；

### renderVNode

渲染`{{}}`这些特殊格式的文本，渲染成数据

### 修改属性后自动渲染

## 属性解析

之前识别的都是节点里的 `text nodeType==3`，现在要识别标签上的属性

- `v-model`

- `v-for`

- `v-bind`

- `v-on`

### v-model 双向数据绑定

input 输入框的双向数据绑定：既可以修改 data 对象，data 对象改了他也会变

### v-for 修改数组后自动渲染

### v-bind，表达式解析，自动执行表达式

### v-on-绑定事件

## 生命周期-created

# 案例调试

使用 Object.defineProperty 对数据进行代理给 data 属性和框架实例
使用树形递归遍历根节点来建立 VNode
使用 ES6 的 Map 方法记录节点和模板以及模板和节点的对应关系
使用代理数据的 set()添加重新构建相关节点并进行渲染实现数据驱动视图等逻辑功能
使用记录的对应关系实现 diff 算法
**项目难点:**1.在 v-for 指令实现过程中遇到困难,自己最后通过在虚拟 VNode 树形结构中把包含 v-for 节点的 dom 定义成
虚拟节点,在递归循环建立虚拟 dom 树过程中遇到包含 v-for 属性时,先在真实 dom 树中删除它,然后通过分析 v-for 属性值建立需要循环得到的节点挂载到它原本真实父节点上,当 v-for 依赖数据变化时在其代理的 set()方法中加入相关逻辑功能(先还原之前处理 v-for 属性然后重新按照这种方法进行 VNode 的更新然后进行重新渲染) 2 在实现 v-bind 指令时,由于可能具有一些表达式用来进行判断是否在真实渲染节点中加入样式,这些指令都是字符串形式,最后自己通过 eval 来运行判断(循环 data 数据拼接字符串)

npm 发布
